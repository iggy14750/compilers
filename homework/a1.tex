\documentclass{article}
\author{Isaac B Goss}
\title{Assignment 1}
\date{}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
% \lstset{
%     basicstyle   = \footnotesize,
%     commentstyle = \color{javagreen},
%     frame        = single,
%     language     = C,
%     stringstyle  = \color{orange},
%     numbers      = left,
%     showstringspaces=false,
%     deletekeywords = {len, max, format, min},
%     morekeywords = {yield, function, then, do, to},
%     keywordstyle = \color{blue},
% }
\providecommand{\coder}[1]{
\begin{lstlisting}[escapeinside={(*}{*)}]
#1
\end{lstlisting}
}

\begin{document}
\maketitle

\begin{enumerate}
    \item Write a regular expression for to match the following things.
    \begin{enumerate}
        \item A power of 2.
        \begin{verbatim}0*10*\end{verbatim}
        \item Valid C/Java integer constants which can be positive or negative, in decimal or hexidecimal.
        \begin{verbatim}-?(0|[1-9][0-9]*|0x[0-9A-Fa-f]*|0[0-9]*)\end{verbatim}
        \item A block comment without nesting.

        \texttt{/\textbackslash*[\^{}*]*\textbackslash*/}
    \end{enumerate}

    \item Using Thompson's Algorithm to convert the following regular expression to an NFA.
    
    \texttt{b?(ab)*bb+}

    Let's normalize the regular expression first.
    
    \texttt{(b|$\epsilon$)(ab)*bbb*}
    
    \image{nfa-first}
    \item Using the algorithm described in class, turn the earlier NFA to a DFA.

    We can use the method described in class (with the $\epsilon$-closure) to construct the DFA states,
    where any of these states which include 14 in their NFA states is an accept state.

    \begin{center}
    \begin{tabular}{c|c|c|c}
        %DFA State & NFA States & a & b \\
        \textbf{DFA State} & \textbf{NFA States} & \textbf{a Transition} & \textbf{b Transition}\\
        \hline\hline
        A & 0,1,3,4,5,6,9 & 7 (B) & 2,5,6,9,10 (C)  \\
        B & 7             & -     & 6,8,9 (D)       \\
        C & 2,5,6,9,10    & 7 (B) & 10,11,12,14 (E) \\
        D & 6,8,9         & 7 (B) & 10 (F)          \\
        E & 10,11,12,14   & -     & 11,12,13,14 (G) \\
        F & 10            & -     & 11,12,14 (H)    \\
        G & 11,12,13,14   & -     & 12,13,14 (I)    \\
        H & 11,12,14      & -     & 12,13,14 (I)    \\
        I & 12,13,14      & -     & 12,13,14 (I)    \\
    \end{tabular}
    \end{center}

    \pagebreak
    \item Give a grammar for the language defined by the regular expression in question 2.

    \begin{center}
        \texttt{
            \begin{tabular}{ll}
                A $\to$ & aB | aC \\
                B $\to$ & aC | bE \\
                C $\to$ & bD      \\
                D $\to$ & aC | bE \\
                E $\to$ & bF      \\
                F $\to$ & bG      \\
                G $\to$ & bG | $\epsilon$
            \end{tabular}
        }
    \end{center}

    \item Give a grammar for the language of Boolean expressions.

    \begin{center}
        \texttt{
            \begin{tabular}{ll}
                Expr $\to$ & (Expr)\\
                Expr $\to$ & Expr "\&\&" Expr \\
                Expr $\to$ & Expr "||" Expr   \\
                Expr $\to$ & "!" Expr         \\
                Expr $\to$ & "true"           \\
                Expr $\to$ & "false"
            \end{tabular}
        }
    \end{center}

\end{enumerate}

\end{document}

























